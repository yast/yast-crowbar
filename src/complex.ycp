/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/crowbar/complex.ycp
 * Package:	Configuration of crowbar
 * Summary:	Dialogs definitions
 * Authors:     Jiri Suchomel <jsuchome@suse.cz>,
 *              Michal Filka <mfilka@suse.cz>
 *
 * $Id: complex.ycp 65771 2011-09-19 07:37:30Z visnov $
 */

{

textdomain "crowbar";

import "Confirm";
import "Crowbar";
import "CWM";
import "CWMTab";
import "FileUtils";
import "Hostname";
import "Label";
import "Popup";
import "Stage";
import "Wizard";
import "IP";
import "Netmask";

include "crowbar/helps.ycp";

boolean ReallyAbort() {
    return !Crowbar::Modified() || Popup::ReallyAbort(true);
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");
    if (!Confirm::MustBeRoot()) return `abort;
    boolean ret = Crowbar::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");
    boolean ret = Crowbar::Write();
    return ret ? `next : `abort;
}


  // local copy of network settings
  map<string,map> networks    = $[];

  // local copy of user settings
  map<string,map> users       = $[];

  // local copy of teaming options
  map<string,integer> teaming      = $[];

  // local copy of repositories
  map<string,map> repos      = $[];

  // local copy of conduit_map
  list<map> conduit_map         = [];

  // if bastion network should be added
  boolean enable_bastion        = false;

  // local copy of mode
  string mode      = "single";

  // bastion network interfaces (present in conduit_map)
  list<string> conduit_if_list        = [];

  string current_network      = "admin";

  string current_user   = "";

  string current_repo   = "";


  define void InitAskOnError (string id) {
    UI::ChangeWidget (`id (id), `Value, repos[current_repo,"ask_on_error"]:false == true);
  }

  define void InitRepoURL (string id) {
    UI::ChangeWidget (`id (id), `Value, repos[current_repo,"url"]:"");
  }

  /**
   * initialize the value of repo table
   */
  define void InitReposTable (string id) {

    UI::ChangeWidget (`id ( id), `Items, maplist (string name, map r, repos, {
      return `item (`id (name), name, r["url"]:"", r["ask_on_error"]:false ? UI::Glyph (`CheckMark) : " ");
    }));
    if (current_repo != "")
      UI::ChangeWidget (`id(id), `CurrentItem, current_repo);
  }

  /**
   * handler for repo selection table
   */
  define symbol HandleReposTable (string key, map event) {

    string selected = (string) UI::QueryWidget (`id(key), `Value);
    if (selected != nil && selected != current_repo)
    {
      current_repo      = selected;
      InitRepoURL ("repo_url");
      InitAskOnError ("ask_on_error");
    }
    return nil;
  }

  define symbol StoreRepoURL (string key, map event) {
    repos[current_repo,"url"]   = UI::QueryWidget (`id (key), `Value);
    return nil;
  }

  define symbol HandleRepoURL (string key, map event) {

    // store the value on exiting
    if (event["ID"]:nil == `next ||
        event["EventReason"]:"" == "ValueChanged")
    {
        StoreRepoURL (key, event);
        InitReposTable ("repos_table");
    }
    return nil;
  }

  define symbol StoreAskOnError (string key, map event) {
    repos[current_repo,"ask_on_error"]   = UI::QueryWidget (`id (key), `Value) == true;
    return nil;
  }

  define symbol HandleAskOnError (string key, map event) {

    // store the value on exiting
    if (event["ID"]:nil == `next ||
        event["EventReason"]:"" == "ValueChanged")
    {
        StoreAskOnError (key, event);
        InitReposTable ("repos_table");
    }
    return nil;
  }



  /**
   * initialize the value of users table
   */
  define void InitUsersTable (string id) {

    UI::ChangeWidget (`id ( id), `Items, maplist (string name, map u, users, {
      return `item (`id (name), name);
    }));
    if (current_user != "" && haskey (users, current_user))
      UI::ChangeWidget (`id(id), `CurrentItem, current_user);
  }

  /**
   * handler for adding user button
   */
  symbol HandleAddEditUserButton (string key, map event) {
    any ID	= event["ID"]:nil;
    if (ID != key)
      return nil;

    UI::OpenDialog (`opt (`decorated), `HBox (`HSpacing (1), `VBox(
      `VSpacing (0.5),
      `HSpacing (65),
      // text entry label
      `InputField (`id (`username), `opt (`hstretch), _("User Name")),
      // text entry label
      `Password (`id (`pw1), `opt (`hstretch), _("Password")),
      // text entry label
      `Password (`id (`pw2), `opt (`hstretch), _("Repeat the Password")),
      `VSpacing (0.5),
      `ButtonBox (
        `PushButton (`id(`ok), Label::OKButton()),
        `PushButton (`id(`cancel), Label::CancelButton())
      ),
      `VSpacing (0.5)), `HSpacing (1))
    );

    if (key == "edit_user")
    {
      UI::ChangeWidget (`id (`username), `Value, current_user);
      UI::ChangeWidget (`id (`pw1), `Value, users[current_user,"password"]:"");
      UI::ChangeWidget (`id (`pw2), `Value, users[current_user,"password"]:"");
    }

    symbol ret = `not_next;
    string name = "";

    while (true)
    {
      ret     = (symbol) UI::UserInput ();
      if (ret == `cancel)
        break;
      if (ret == `ok)
      {
        name = (string) UI::QueryWidget (`id (`username), `Value);
        string pass = (string) UI::QueryWidget (`id (`pw1), `Value);

        if (pass != UI::QueryWidget (`id (`pw2), `Value))
        {
          // error popup
          Popup::Error(_("The passwords do not match.
Try again."));
          UI::SetFocus (`id(`pw1));
          continue;
        }
        if (haskey (users, name) &&
           (key == "add_user" || name != current_user))
        {
          // error popup
          Popup::Error (sformat (_("User '%1' already exists.
Choose a different name."), name));
          UI::SetFocus (`id(`username));
          continue;
        }
        if (key == "edit_user")
        {
          users         = remove (users, current_user);
        }
        users[name]     = $[ "password" : pass ];
        break;
      }
    }
    UI::CloseDialog ();

    if (ret == `ok)
    {
      current_user      = name;
      InitUsersTable ("users_table");
      UI::ChangeWidget (`id ("delete_user"), `Enabled, size (users) > 0);
      UI::ChangeWidget (`id ("edit_user"), `Enabled, size (users) > 0);
    }
    return nil;
  }

  /**
   * handler for user selection table
   */
  define symbol HandleUsersTable (string key, map event) {

    string selected = (string) UI::QueryWidget (`id(key), `Value);
    if (selected != nil && selected != current_user)
    {
      current_user      = selected == nil ? "" : selected;
    }
    if (key == event["ID"]:nil && event["EventReason"]:"" == "Activated")
    {
      HandleAddEditUserButton ("edit_user", $["ID" : "edit_user"]);
    }
    return nil;
  }


  /**
   * handler for user button
   */
  symbol HandleDeleteUserButton (string key, map event) {
    any ID	= event["ID"]:nil;
    if (ID != key)
      return nil;
    // yes/no popup question
    if (true) // Popup::YesNo (sformat (_("Really delete user '%1'?"), current_user)))
    {
      users             = remove (users, current_user);
      InitUsersTable ("users_table");
      current_user      = size (users) == 0 ? "" : (string) UI::QueryWidget (`id("users_table"), `Value);
      UI::ChangeWidget (`id (key), `Enabled, size (users) > 0);
      UI::ChangeWidget (`id ("edit_user"), `Enabled, size (users) > 0);
    }
    return nil;
  }


  // functions for handling network mode widget
  define void InitMode (string id) {
    list items	=  [
	`item (`id ("single"), "single", "single" == mode),
	`item (`id ("dual"), "dual", "dual" == mode),
	`item (`id ("team"), "team", "team" == mode),
    ];
    UI::ChangeWidget (`id (id), `Items, items);
    UI::ChangeWidget (`id (id), `Enabled, !Crowbar::installed);
  }

  define void StoreMode (string key, map event) {
    mode        = (string) UI::QueryWidget (`id(key), `Value);
  }

  define symbol HandleMode (string key, map event) {
    StoreMode (key, event);
    UI::ChangeWidget (`id ("teaming"), `Enabled, mode == "team");
    return nil;
  }

  void InitConduitList (string id) {
    UI::ChangeWidget (`id (id), `Value, mergestring (conduit_if_list, " "));
  }

  void StoreConduitList (string key, map event) {
    conduit_if_list     = splitstring ((string) UI::QueryWidget (`id(key), `Value), " ");
  }


  // functions for handling network teaming widget
  define void InitTeaming (string id) {
    integer value       = teaming["mode"]:0;
    list items          = [];
    integer i           = 0;
    while (i < 7)
    {
      items     = add (items, `item (`id (i), tostring (i), i == value));
      i         = i + 1;
    }
    UI::ChangeWidget (`id (id), `Items, items);
    UI::ChangeWidget (`id (id), `Enabled, mode == "team");
    UI::ChangeWidget (`id (id), `Enabled, !Crowbar::installed);
  }

  define void StoreTeaming (string key, map event) {
    teaming["mode"]     = (integer) UI::QueryWidget (`id(key), `Value);
  }

  define symbol HandleTeaming (string key, map event) {
    if (event["ID"]:nil == `next) StoreTeaming (key, event);
    return nil;
  }

  /*
   * Returns current subnet as filled in dialog
   */
  define string GetSubnet()
  {
        return (string) UI::QueryWidget( `id( "subnet"), `Value);
  }

  /*
   * Returns current netmask as filled in dialog
   */
  define string GetNetmask()
  {
        return (string) UI::QueryWidget( `id( "netmask"), `Value);
  }

  /*
   * Returns broadcast address. Based on current netmask and subnet
   */
  define string GetBroadcast()
  {
      return IP::ComputeBroadcast( GetSubnet(), GetNetmask());
  }

  define term CreateItem( string name)
  {
      return `item (`id (name),
        name,
        networks[name,"subnet"]:"",
        networks[name,"netmask"]:"",
        // table entry (VLAN status)
        networks[name,"use_vlan"]:false ? sformat ("%1", networks[name,"vlan"]:0) : _("disabled")
      );
  }

  define list<term> CreateItemList()
  {
      list<term> items  = [];
      foreach (string name, map n, networks, {
          if (name != "bastion")
            items       = add (items, CreateItem (name));
      });
      return items;
  }
  /**
   * universal widget: initialize the string value of widget @param
   */
  define void InitNetwork (string id) {
    UI::ChangeWidget (`id (id), `Enabled, !Crowbar::installed);
    if( id == "broadcast")
    {
        UI::ChangeWidget (`id (id), `Value, GetBroadcast());
        return;
    }

    UI::ChangeWidget (`id (id), `Value, networks[current_network,id]:"");
  }

  /**
   * universal widget: initialize the integer value of widget @param
   */
  define void InitInteger (string id) {

    UI::ChangeWidget (`id (id), `Value, networks[current_network,id]:0);
    if (id == "vlan")
    {
        UI::ChangeWidget (`id (id), `Enabled, networks[current_network,"use_vlan"]:false == true);
    }
    UI::ChangeWidget (`id (id), `Enabled, !Crowbar::installed);
  }

  /**
   * initialize the value of table
   */
  define void InitNetworkSelect (string id) {
    if (CWMTab::CurrentTab () == "networks")
    {
      if (current_network == "bastion")
        current_network = "admin";

      UI::ChangeWidget (`id ( id), `Items, CreateItemList());
      UI::ChangeWidget (`id(id), `CurrentItem, current_network);
    }
  }

  /**
   * store the string value of given widget
   */
  define void StoreNetwork (string key, map event) {
    if (size (networks) == 0 ||
       (CWMTab::CurrentTab () == "bastion" && !enable_bastion))
    {
        return;
    }
    if (key == "router" && UI::QueryWidget (`id(key), `Value) == "")
    {
        if (haskey (networks[current_network]:$[], key))
        {
          // do not save empty router values to json
          networks[current_network]       = remove (networks[current_network]:$[], key);
        }
        return;
    }
    if( key == "subnet")
    {
        networks[ current_network, key] = IP::ComputeNetwork( GetSubnet(), GetNetmask());
        return;
    }
    networks[current_network,key]      = UI::QueryWidget (`id(key), `Value);
  }

  /**
   * Validate entered network values
   */
  define boolean ValidateNetwork( string key, map event)
  {
      boolean ret = true;

      if (event["WidgetID"]:nil == `back || size (networks) == 0)
      {
        return true;
      }
      if (CWMTab::CurrentTab () == "bastion" && !enable_bastion)
      {
        return true;
      }

      string subnet = GetSubnet();
      string netmask = GetNetmask();
      string router = (string) UI::QueryWidget (`id ("router"), `Value);
      string ip = "";
      if (UI::WidgetExists (`id ("ip")))
      {
        ip      = (string) UI::QueryWidget (`id ("ip"), `Value);
      }

      ret = (key != "netmask") || Netmask::Check(netmask);
      if (!ret)
      {
          // error popup
          Popup::Error (sformat (_("The netmask '%1' is invalid.\n%2"), netmask, IP::Valid4 ()));
          return false;
      }

      ret = (key != "subnet") || IP::Check (subnet);
      if (!ret)
      {
          // error popup
          Popup::Error (sformat (_("The IP address '%1' is invalid.\n%2"), subnet, IP::Valid4 ()));
          return false;
      }
      if (key == "router" && router != "")
      {
          if (!IP::Check (router))
          {
            // error popup
            Popup::Error (sformat (_("The router address '%1' is invalid.\n%2"), router, IP::Valid4 ()));
            return false;
          }
          if (IP::ComputeNetwork (subnet,netmask) != IP::ComputeNetwork (router, netmask))
          {
            // error popup
            Popup::Error (sformat (_("The router address '%1' is not part of network '%2'."), router, current_network));
            return false;
          }
      }
      if (key == "ip" && ip != "")
      {
          if (!IP::Check (ip))
          {
            // error popup
            Popup::Error (sformat (_("The IP address '%1' is invalid.\n%2"), ip, IP::Valid4 ()));
            return false;
          }
          if (IP::ComputeNetwork (subnet,netmask) != IP::ComputeNetwork (ip, netmask))
          {
            // error popup
            Popup::Error (sformat (_("The IP address '%1' is not part of network '%2'."), ip, current_network));
            return false;
          }
      }
      // check if ranges are still in network
      if (key == "subnet")
      {
          boolean ranges_fine   = true;
          foreach (string name, map range, networks[current_network,"ranges"]:$[], {
            foreach (string part, [ "start", "end" ], {
              string ip   = range[part]:"";
              if (IP::ComputeNetwork (ip, netmask) != subnet)
              {
                ranges_fine    = false;
              }
            });
          });
          if (!ranges_fine)
          {
            // popup message
            Popup::Warning (sformat (_("Some address ranges are not part of network '%1'.
Adapt them using 'Edit ranges' button."), current_network));
            return false;
          }
      }
      return ret;
  }

  /**
   * handler for general string-value widgets: store their value on exit/save
   */
  define symbol HandleNetwork (string key, map event) {

    if (key == "use_vlan" && event["ID"]:nil == "use_vlan")
    {
        UI::ChangeWidget (`id ("vlan"), `Enabled, UI::QueryWidget (`id(key), `Value) == true);
    }
    // store the value on exiting
    if (event["EventReason"]:"" == "ValueChanged")
    {
        if (IP::Check( GetSubnet()) && IP::Check( GetNetmask()))
        {
            UI::ChangeWidget( `id( "broadcast"), `Value, GetBroadcast());
            StoreNetwork( event[ "ID"]:"", event);

            InitNetworkSelect ("network_select");
        }
    }
    if (event["ID"]:nil == `next) StoreNetwork (key, event);
    return nil;
  }


  /**
   * universal widget: initialize the string value of widget @param
   */
  define void InitCheckBox (string id) {
    UI::ChangeWidget (`id (id), `Value, networks[current_network,id]:false);
    UI::ChangeWidget (`id (id), `Enabled, !Crowbar::installed);
  }

  /**
   * handler network selection table
   */
  define symbol HandleNetworkSelect (string key, map event) {

    string selected = (string) UI::QueryWidget (`id(key), `Value);
    if (selected != current_network)
    {
      boolean validated = true;
      foreach (string key, ["netmask", "subnet", "router"], {
        validated       = validated && ValidateNetwork (key, event);
      });
      if (!validated)
      {
        UI::ChangeWidget (`id(key), `CurrentItem, current_network);
        return nil;
      }
      foreach (string key, ["netmask", "subnet", "add_bridge", "use_vlan", "vlan", "broadcast", "router"], {
        StoreNetwork (key, $[]);
      });
      current_network   = selected;
      foreach (string key, ["netmask", "subnet", "broadcast", "router"], {
        InitNetwork (key);
      });
      InitCheckBox ("use_vlan");
      InitCheckBox ("add_bridge");
      InitInteger ("vlan");
    }
    return nil;
  }

  /**
   * handler for ranges button
   */
  symbol HandleRangesButton (string key, map event) {
    any ID	= event["ID"]:nil;
    if (ID != key)
      return nil;

    string subnet               = networks[current_network,"subnet"]:"";
    string netmask              = networks[current_network,"netmask"]:"";
    map<string,map> ranges      = networks[current_network,"ranges"]:$[];
    term ranges_term    = `VBox ();

    foreach (string name, map range, ranges, {

      term r = `Frame (name, `HBox (
        `InputField (`id (name + "_start"), `opt (`hstretch),
          // inputfield label
          _("Min IP Address"), range["start"]:""),
        `InputField (`id (name + "_end"), `opt (`hstretch),
          // inputfield label
          _("Max IP Address"), range["end"]:"")
      ));
      ranges_term       = add (ranges_term, r);
    });

    UI::OpenDialog (`opt (`decorated), `HBox (`HSpacing (1), `VBox(
      `VSpacing (0.5),
      `HSpacing (65),
      ranges_term,
      `VSpacing (0.5),
      `ButtonBox (
        `PushButton (`id(`ok), Label::OKButton()),
        `PushButton (`id(`cancel), Label::CancelButton())
      ),
      `VSpacing (0.5)), `HSpacing (1))
    );

    foreach (string name, map range, ranges, {
      UI::ChangeWidget (`id (name + "_start"),`ValidChars, IP::ValidChars4 + IP::ValidChars6);
      UI::ChangeWidget (`id (name + "_end"),`ValidChars, IP::ValidChars4 + IP::ValidChars6);
      UI::ChangeWidget (`id (name + "_start"), `Enabled, !Crowbar::installed);
      UI::ChangeWidget (`id (name + "_end"), `Enabled, !Crowbar::installed);
    });

    UI::ChangeWidget (`id (`ok), `Enabled, !Crowbar::installed);

    symbol ret = `not_next;
    while (true)
    {
	ret     = (symbol) UI::UserInput ();
        if (ret == `cancel)
        {
          break;
        }
        if (ret == `ok)
        {
          string widget         = "";
          list<list> ranges_l   = [];
          foreach (string name, map range, ranges, {
            if (widget != "")
            {
              return;
            }
            foreach (string part, [ "start", "end" ], {
              string ip   = (string) UI::QueryWidget (`id (name + "_" + part), `Value);
              if (!IP::Check (ip))
              {
                Popup::Error (IP::Valid4 ());
                widget  = name + "_" + part;
              }
              else if (IP::ComputeNetwork (ip, netmask) != subnet)
              {
                Popup::Error (sformat (_("The address '%1' is not part of network '%2'."),
                  ip, current_network));
                widget  = name + "_" + part;
              }
              ranges[name,part] = ip;
            });
            if (widget == "" &&
                IP::ToInteger (ranges[name,"start"]:"") > IP::ToInteger (ranges[name,"end"]:""))
            {
              // error message
              Popup::Error (_("The lowest address must be lower than the highest one."));
              widget  = name + "_end";
            }
            else
            {
              ranges_l  = add (ranges_l, [
                IP::ToInteger (ranges[name,"start"]:""),
                IP::ToInteger (ranges[name,"end"]:""),
                name
              ]);
            }
          });
          // check if ranges do not overlap
          if (widget == "" && size (ranges_l) > 1)
          {
            ranges_l    = sort (list a, list b, ranges_l, {
              return (a[0]:0 <= b[0]:0);
            });
            integer i   = 0;
            while (i < size (ranges_l) - 1) {
              list this = ranges_l[i]:[];
              list next = ranges_l[i + 1]:[];
              if (this[1]:0 >= next[0]:0)
              {
                // error message
                Popup::Error (sformat (_("Ranges '%1' and '%2' are overlapping."),
                  this[2]:"", next[2]:""));
                widget  = next[2]:"" + "_start";
              }
              i = i + 1;
            }
          }
          // finally, save the ranges
          if (widget == "")
          {
            networks[current_network,"ranges"]  = ranges;
            break;
          }
          else
          {
            ret = `not_next;
            UI::SetFocus (`id (widget));
            continue;
          }
        }
    }

    UI::CloseDialog ();
    return nil;
  }

  void enable_disable_bastion () {
    foreach (string w, [ "ip", "router", "subnet", "netmask", "broadcast", "use_vlan"], {
      UI::ChangeWidget (`id (w), `Enabled, enable_bastion);
    });
    UI::ChangeWidget (`id ("vlan"), `Enabled, enable_bastion && networks[current_network,"use_vlan"]:false == true);
  }

  /**
   * initialize the value of Enable Bastion checkbox
   */
  define void InitBastionCheckbox (string id) {
    current_network   = "bastion";

    UI::ChangeWidget (`id (id), `Enabled, !Crowbar::installed);
    UI::ChangeWidget (`id (id), `Value, enable_bastion);
    enable_disable_bastion ();
  }

  define symbol HandleBastionCheckbox (string key, map event) {
    enable_bastion      = UI::QueryWidget (`id(key), `Value) == true;
    enable_disable_bastion ();
    return nil;
  }

map<string, map> widget_description	= $[
    // ---------------- widgets for Repositories tab
    "repos_table" : $[
        "widget"        : `custom,
        "custom_widget" :
          `VBox (
              `VWeight (2, `Table (`id( "repos_table"),
                  `opt (`notify, `immediate, `hstretch),
                  // table header
                  `header (_("Repository Name"), _("URL"), _("Ask On Error"))
              ))
          ),
        "init"          : InitReposTable,
        "handle"        : HandleReposTable,
        // help text
        "help"          : _("<p>Here you can edit the location of your update repositores.</p>")
    ],
    "repo_url" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Repository &URL"),
        /* FIXME
        "validate_type" : `function,
        "validate_function": ValidateURL,
        */
        "no_help"       : true,
	"init"		: InitRepoURL,
	"store"		: StoreRepoURL,
	"handle"	: HandleRepoURL,
        "opt"           : [ `notify ],
    ],
    "ask_on_error"      : $[
	"widget"	: `checkbox,
	// textentry label
	"label"		: _("&Ask On Error"),
        "no_help"       : true,
	"init"		: InitAskOnError,
	"store"		: StoreAskOnError,
	"handle"	: HandleAskOnError,
        "opt"           : [ `notify ],
    ],
    // ---------------- widgets for Users tab
    "users_table" : $[
        "widget"        : `custom,
        "custom_widget" :
          `VBox (
              `VWeight (2, `Table (`id( "users_table"),
                  `opt (`notify, `immediate, `hstretch),
                  // table header
                  `header (_("Administrator Name"))
              ))
          ),
        "init"          : InitUsersTable,
        "handle"        : HandleUsersTable,
        // help text
        "help"          : _("<p>Manage user names and passwords for Crowbar administrators.</p>")
    ],
    "add_user"	: $[
	"widget"	: `push_button,
	"label"		: Label::AddButton(),
        "no_help"       : true,
	"handle"	: HandleAddEditUserButton
    ],
    "edit_user"	: $[
	"widget"	: `push_button,
	"label"		: Label::EditButton(),
        "no_help"       : true,
	"handle"	: HandleAddEditUserButton
    ],
    "delete_user"	: $[
	"widget"	: `push_button,
	"label"		: Label::DeleteButton(),
        "no_help"       : true,
	"handle"	: HandleDeleteUserButton
    ],
    // ---------------- widgets for Network Mode tab
    "mode" : $[
	"widget"	: `combobox,
	"opt"		: [ `hstretch, `notify ],
	// textentry label
	"label"		: _("&Mode"),
        // help text for the Network mode tab (do not translate bastion)
        "help"          : _("<p>Here, define a <b>Network Mode</b> with relevant <b>Bonding Policy</b>.</p>
<p>You can also specify interface names for the bastion network conduits as space-separated list.</p>"),
	"init"		: InitMode,
	"store"		: StoreMode,
	"handle"	: HandleMode,
    ],
    "teaming" : $[
	"widget"	: `combobox,
	// textentry label
	"label"		: _("Bonding &Policy"),
        "no_help"       : true,
	"init"		: InitTeaming,
	"store"		: StoreTeaming,
	"handle"	: HandleTeaming,
    ],
    "conduit_if_list" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Logical interfaces for bastion network conduits"),
        /* FIXME
        "validate_type" : `function,
        "validate_function": ValidateConduitList,
        */
        "no_help"       : true,
	"init"		: InitConduitList,
	"store"		: StoreConduitList,
    ],
    // ---------------- widgets for Network tab

    "network_help"      : $[
        "widget"        : `empty,
        // generic help for Network tab
        "help"          : HELPS["overview"]:"",
    ],
    "network_select" : $[
        "widget"        : `custom,
        "custom_widget" :
          `VBox (
              `VWeight (2, `Table (`id( "network_select"),
                  `opt (`notify, `immediate, `hstretch),
                  // table header
                  `header (_("Network"), _("Subnet Address"), _("Network Mask"), _("VLAN"))
              ))
          ),
        "init"          : InitNetworkSelect,
        "handle"        : HandleNetworkSelect,
        "no_help"       : true,
    ],
    "use_vlan" : $[
	"widget"	: `checkbox,
	// checkbox label
	"label"		: _("Use &VLAN"),
        "no_help"       : true,
	"init"		: InitCheckBox,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
        "opt"           : [ `notify ],
    ],
    "vlan" : $[
	"widget"	: `intfield,
	// textentry label
	"label"		: _("VLAN &ID"),
        "no_help"       : true,
	"init"		: InitInteger,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
	"opt"		: [ `notify, `hstretch ],
    ],
    "router" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Rou&ter"),
        "validate_type" : `function,
        "validate_function": ValidateNetwork,
        "valid_chars"   : IP::ValidChars4 + IP::ValidChars6,
        "no_help"       : true,
	"init"		: InitNetwork,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
        "opt"           : [ `notify ],
    ],
    "subnet" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("&Subnet"),
        "handle_events" : [ "ValueChanged" ],
        "validate_type" : `function,
        "validate_function": ValidateNetwork,
        "valid_chars"   : IP::ValidChars4 + IP::ValidChars6,
        "no_help"       : true,
	"init"		: InitNetwork,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
        "opt"           : [ `notify ],
    ],
    "netmask" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("Net&mask"),
        "handle_events" : [ "ValueChanged" ],
        "validate_type" : `function,
        "validate_function": ValidateNetwork,
        "valid_chars"   : IP::ValidChars4 + IP::ValidChars6,
        "no_help"       : true,
	"init"		: InitNetwork,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
        "opt"           : [ `notify ],
    ],
    "broadcast" : $[
	"widget"	: `textentry,
	"label"		: _("Broa&dcast"),
        "valid_chars"   : IP::ValidChars4 + IP::ValidChars6,
        "no_help"       : true,
	"init"		: InitNetwork,
	"store"		: StoreNetwork,
	"opt"		: [ `disabled ]
    ],
    "add_bridge" : $[
	"widget"	: `checkbox,
	// checkbox label
	"label"		: _("&Add Bridge"),
        "no_help"       : true,
	"init"		: InitCheckBox,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
    ],
    "ranges_button"	: $[
	"widget"	: `push_button,
	// push button label&
	"label"		: _("Edit Ran&ges..."),
        "no_help"       : true,
	"handle"	: HandleRangesButton
    ],
    // ---------------- widgets for Bastion
    "enable_bastion"      : $[
        "widget"        : `checkbox,
	// checkbox label
	"label"		: _("Add Bastion Network"),
        "help"          : HELPS["bastion"]:"",
        "init"          : InitBastionCheckbox,
//	"store"		: StoreBastionCheckbox,
	"handle"	: HandleBastionCheckbox,
        "opt"           : [ `notify ],
    ],
    "ip" : $[
	"widget"	: `textentry,
	// textentry label
	"label"		: _("&IP Address"),
        "handle_events" : [ "ValueChanged" ],
        "validate_type" : `function,
        "validate_function": ValidateNetwork,
        "valid_chars"   : IP::ValidChars4 + IP::ValidChars6,
        "no_help"       : true,
	"init"		: InitNetwork,
	"store"		: StoreNetwork,
	"handle"	: HandleNetwork,
        "opt"           : [ `notify ],
    ],
];

// description of tab layouts
map get_tabs_descr () {
  return $[
    "users" : $[
	// tab header
	"header"	: _("&User Settings"),
	"contents"	: `HBox (`HSpacing(2), `VBox (
	    `VSpacing (),
            "users_table",
	    `VSpacing (0.4),
            `HBox (
              "add_user", "edit_user", "delete_user", `HStretch ()
            ),
            `VSpacing (2),
            // label (hint for user)
            `Left (`Label (_("If no user is present, user 'crowbar' with default password will be used."))),
	    `VStretch ()
	), `HSpacing(2)),
	"widget_names" : [
            "add_user", "delete_user", "edit_user", "users_table",
	],
    ],
    "network_mode"      : $[
	// tab header
	"header"	: _("N&etwork Mode"),
	"contents"	: `HBox (`HSpacing(2), `VBox (
	    `VSpacing (),
            `HBox (
              "mode",
              "teaming"
            ),
            `VSpacing (2),
            "conduit_if_list",
	    `VStretch ()
	), `HSpacing(2)),
	"widget_names" : [
            "mode", "teaming", "conduit_if_list"
	],
    ],
    "networks"	: $[
	// tab header
	"header"	: _("Net&works"),
	"contents"	: `HBox (`HSpacing(2), `VBox (
            "network_help",
	    `VSpacing (),
            "network_select",
	    `Left ("add_bridge"),
	    `VSpacing (0.4),
            `HBox (
              `VBox (
                "use_vlan",
                `Label ("")
              ),
              `HSpacing (2),
              "vlan"
            ),
            "router",
            `HBox (
	      "subnet",
	      "netmask",
	      "broadcast"
            ),
	    `VSpacing (0.4),
            `Right ("ranges_button")
	), `HSpacing (2)),
	"widget_names" : [
            "network_select", "vlan", "router", "subnet", "netmask", "broadcast", "add_bridge",
            "ranges_button", "use_vlan", "network_help",
	],
    ],
    "repositories" : $[
	// tab header
	"header"	: _("Re&positories"),
	"contents"	: `HBox (`HSpacing(2), `VBox (
	    `VSpacing (),
            "repos_table",
	    `VSpacing (0.4),
            `Left ("ask_on_error"),
            `VSpacing (),
            "repo_url",
            // label (hint for user)
            `Left (`Label (_("Empty URL means that default value will be used."))),
	    `VStretch ()
	), `HSpacing(2)),
	"widget_names" : [
            "repos_table", "repo_url", "ask_on_error"
	],
    ],
    "bastion"	: $[
	// tab header
	"header"	: _("Bastion Network"),
	"contents"	: `HBox (`HSpacing(2), `VBox (
	    `VSpacing (),
            `Left ("enable_bastion"),
	    `VSpacing (),
            "ip",
            `HBox (
              `VBox (
                "use_vlan",
                `Label ("")
              ),
              `HSpacing (2),
              "vlan"
            ),
            "router",
            `HBox (
	      "subnet",
	      "netmask",
	      "broadcast"
            ),
	    `VStretch ()
	), `HSpacing (2)),
	"widget_names" : [
            "enable_bastion",
            "ip", "vlan", "router", "subnet", "netmask", "broadcast", "use_vlan",
	],
    ],
  ];
}

/**
 * Adapts global conduit_map:
 *      - add new subsection for bastion network with conduit_if_list value (entered by user)
 *      - if conduit value for bastion is not defined, generate new (unique) one
 *      - find place for bastion in conduit list by checking mode pattern
 * @return: new conduit name (
 */
string adapt_conduit_map (string conduit) {

  string conduit_name   = conduit;
  boolean name_found    = false;

  conduit_map   = maplist (map c_map, conduit_map, {

    // ignore not matching patterns
    if (substring (c_map["pattern"]:"", 0, size (mode)) != mode)
    {
      return c_map;
    }

    if (!name_found)
    {
      // if non-empty conduit was provided && it exist for the right pattern, use it
      if (haskey (c_map["conduit_list"]:$[], conduit))
      {
        name_found      = true;
      }
      // otherwise, generate unique conduit_name
      else
      {
        if (conduit == "")
        {
          conduit       = "bastion";
          conduit_name  = "bastion";
        }
        integer i         = 0;
        while (haskey (c_map["conduit_list"]:$[], conduit_name))
        {
          conduit_name  = sformat("%1%2", conduit, i);
          i             = i + 1;
        }
        name_found        = true;
      }
    }
    c_map["conduit_list",conduit_name]  = $[
      "if_list" :  conduit_if_list
    ];
    return c_map;
  });
  return conduit_name;
}

/**
 * Find if_list relevant for given bastion network
 */
list<string> get_conduit_if_list (map bastion) {

  string conduit_name   = bastion["conduit"]:"";
  foreach (map c_map, conduit_map, {
    if (substring (c_map["pattern"]:"", 0, size (mode)) == mode)
    {
      if (haskey (c_map["conduit_list"]:$[], conduit_name))
      {
        conduit_if_list = c_map["conduit_list",conduit_name,"if_list"]:[];
      }
    }
  });

  return conduit_if_list;
}

symbol OverviewDialog() {

    networks    = Crowbar::networks;
    mode        = Crowbar::mode;
    teaming     = Crowbar::teaming;
    users       = Crowbar::users;
    repos       = Crowbar::repos;
    conduit_map = Crowbar::conduit_map;
    enable_bastion      = haskey (networks, "bastion");
    if (!enable_bastion)
    {
      networks["bastion"]       = $[];
    }
    else
    {
      networks["bastion","ip"]  = networks["bastion","ranges","admin","start"]:"0";
      conduit_if_list   = get_conduit_if_list (networks["bastion"]:$[]);
    }

    widget_description["tab"] = CWMTab::CreateWidget($[
	"tab_order"	: [ "users", "networks", "network_mode", "repositories", "bastion" ],
	"tabs"		: get_tabs_descr (),
	"widget_descr"	: widget_description,
	"initial_tab"	: "users",
    ]);

    Wizard::SetContentsButtons("", `VBox (), "",
        Label::BackButton(), Label::FinishButton());

    if (Crowbar::installed)
    {
        // popup message %1 is FQDN
        Popup::Message (sformat (_("The SUSE Cloud Admin Server has been deployed. Changing the network is
currently not supported.

You can visit the Crowbar web UI on http://%1:3000/"), Hostname::CurrentFQ ()));
    }


    symbol ret = CWM::ShowAndRun ($[
	"widget_names"		: [
	    "tab"
	],
	"widget_descr"		: widget_description,
	"contents"		: `VBox ("tab"),
	// default dialog caption
        "caption"               : _("Crowbar Configuration Overview"),
	"abort_button"		: Stage::cont () ? Label::AbortButton () : nil,
	"next_button"		: Stage::cont () ? Label::NextButton () : Label::OKButton (),
	"back_button"		: Stage::cont () ? Label::BackButton () : Label::CancelButton (),
    ]);
    if (Crowbar::installed)
    {
      // not saving
      return `back;
    }
    if (ret == `next)
    {
      if (enable_bastion)
      {
        // remove internal "ip" key and transform it to ranges (ip-ip)
        map bastion     = networks["bastion"]:$[];
        if (!haskey (bastion, "ranges"))
        {
          bastion["ranges"]     = $[];
        }
        bastion["ranges","admin"]       = $[
          "start"       : bastion["ip"]:"0",
          "end"         : bastion["ip"]:"0",
        ];
        bastion = remove (bastion, "ip");
        // add conduit to bastion network submap
        bastion["conduit"]      = adapt_conduit_map (bastion["conduit"]:"");
        bastion["add_bridge"]   = false;
        networks["bastion"]     = bastion;
      }
      else if (haskey (networks, "bastion"))
      {
        networks        = remove (networks, "bastion");
      }
      Crowbar::networks = networks;
      Crowbar::conduit_map      = conduit_map; // was adapted by adapt_conduit_map
      Crowbar::users    = users;
      Crowbar::teaming  = teaming;
      Crowbar::mode     = mode;
      Crowbar::repos    = repos;
    }
    return ret;
}

/* EOF */
}
